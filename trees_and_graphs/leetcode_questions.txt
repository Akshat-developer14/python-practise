This is a **High-Yield List** of 30 Tree & Graph problems, specifically curated for Data Science interviews.

Unlike software engineers who build databases, Data Scientists use Trees/Graphs to model **Hierarchies** (Decision Trees, Taxonomies) and **Networks** (Social Graphs, Recommendation Systems).

I have categorized these by the **Pattern** you need to master.

-----

### **Part 1: Trees (The "Hierarchy" Pattern)**

*Focus: Recursion. If you can write a recursive function, you can solve 90% of these.*

#### **Category 1: Basic Traversals (DFS/BFS)**

*Why: Used in Feature Engineering to flatten nested JSON or XML data.*

| Difficulty | Problem Name | Key Logic / Why it's important |
| :--- | :--- | :--- |
| **Easy** | 1. Maximum Depth of Binary Tree | **(Base Case)**: `return 1 + max(left, right)`. Fundamental recursion. |
| **Easy** | 2. Invert Binary Tree | **(Famous)**: Swap left/right children. (Famously asked by Google to Max Howell). |
| **Easy** | 3. Symmetric Tree | Compare `left.left` with `right.right`. Tests mirror logic. |
| **Easy** | 4. Same Tree | Structural comparison. Useful for comparing two model architectures. |
| **Easy** | 5. Balanced Binary Tree | Compare heights of subtrees. If diff \> 1, return False. |
| **Easy** | 6. Diameter of Binary Tree | Longest path between *any* two nodes (doesn't have to pass through root). |
| **Easy** | 7. Subtree of Another Tree | Serialization pattern or recursive matching. |

#### **Category 2: Binary Search Trees (BST)**

*Why: Conceptually identical to how Databases index data for fast retrieval ($O(\log N)$).*

| Difficulty | Problem Name | Key Logic / Why it's important |
| :--- | :--- | :--- |
| **Medium** | 8. Validate Binary Search Tree | **(Must Know)**: Every node must be within range `(min, max)`. |
| **Medium** | 9. Lowest Common Ancestor (BST) | **(Data Science)**: Finding the closest shared category in a taxonomy. |
| **Medium** | 10. Kth Smallest Element in a BST | In-order traversal of a BST gives a **sorted** array. |
| **Medium** | 11. Convert Sorted Array to BST | **(ML Relevance)**: Exactly how a Decision Tree splits continuous data. |

#### **Category 3: Tree Construction & Modification**

*Why: Tests your ability to build data structures from raw inputs.*

| Difficulty | Problem Name | Key Logic / Why it's important |
| :--- | :--- | :--- |
| **Medium** | 12. Construct Tree from Preorder/Inorder | **(Hard)**: Rebuilding a structure from traversal logs. |
| **Medium** | 13. Serialize and Deserialize Binary Tree | **(System Design)**: How to save a model to a file and load it back. |
| **Medium** | 14. Binary Tree Right Side View | Level-order traversal (BFS) taking the last element. |
| **Medium** | 15. Path Sum II | Backtracking: Find all paths that sum to a target (Feature extraction). |
| **Medium** | 16. House Robber III | **(DP on Trees)**: Advanced optimization on hierarchical data. |

-----

### **Part 2: Graphs (The "Network" Pattern)**

*Focus: BFS for Shortest Path, DFS for Connectivity. These are huge for companies like **Uber, Zomato, LinkedIn**.*

#### **Category 4: Matrix Graphs (Grid traversal)**

*Why: A matrix is just an image (pixels) or a map grid. Essential for Computer Vision & Logistics.*

| Difficulty | Problem Name | Key Logic / Why it's important |
| :--- | :--- | :--- |
| **Medium** | 17. Number of Islands | **(The \#1 Graph Q)**: Count connected components (DFS/BFS). |
| **Medium** | 18. Rotting Oranges | **(BFS)**: Multi-source BFS to find "time to infection". |
| **Medium** | 19. Max Area of Island | Variation of Number of Islands. Good for image segmentation logic. |
| **Medium** | 20. Surrounded Regions | Capture surrounded regions (Board games/Go logic). |
| **Medium** | 21. Word Search | **(Backtracking)**: DFS on a grid to find a string. |

#### **Category 5: Adjacency Lists (Social Networks)**

*Why: Recommendation Engines ("People you may know").*

| Difficulty | Problem Name | Key Logic / Why it's important |
| :--- | :--- | :--- |
| **Medium** | 22. Clone Graph | Deep copy a complex web of objects. |
| **Medium** | 23. Course Schedule | **(Topological Sort)**: Detecting cycles in dependencies (Airflow/Pipeline DAGs). |
| **Medium** | 24. Course Schedule II | Return the *order* of courses. (Pipeline execution order). |
| **Medium** | 25. Graph Valid Tree | Check if a graph has no cycles and is fully connected. |
| **Medium** | 26. Number of Connected Components | **(Clustering)**: Finding distinct communities in a social graph. |

#### **Category 6: Advanced Graph Algorithms**

*Why: Optimization problems (Logistics, Routing).*

| Difficulty | Problem Name | Key Logic / Why it's important |
| :--- | :--- | :--- |
| **Medium** | 27. Network Delay Time | **(Dijkstraâ€™s Algo)**: Shortest path in a weighted graph (Routing). |
| **Medium** | 28. Cheapest Flights Within K Stops | **(BFS/Bellman-Ford)**: Pricing optimization in travel. |
| **Hard** | 29. Word Ladder | **(BFS)**: Shortest transformation sequence. |
| **Hard** | 30. Alien Dictionary | **(Topological Sort)**: Inferring order from a list of sorted rules. |

-----

### **Your "Indian Interview" Priority List**

If 30 feels like too much, focus on these **Top 5** first. These are the "Filter Questions" used by Indian interviewers to check if you know your stuff.

1.  **Level Order Traversal (BFS)**:

[Image of Binary Tree Level Order Traversal]

```
* *Why:* If you can't traverse a tree level-by-level, you fail immediately.
```

2.  **Number of Islands**:
      * *Why:* The standard test for "Do you understand Graph DFS?"
3.  **Validate Binary Search Tree**:
      * *Why:* Tests recursion + understanding of data sorting properties.
4.  **Course Schedule (Detect Cycle)**:
      * *Why:* Vital for Data Engineering (DAGs).
5.  **Lowest Common Ancestor**:
      * *Why:* Tests pure recursive logic without needing complex data structures.

**Next Step:** Would you like to start with **"Number of Islands"**? It is the perfect bridge between Matrices (Arrays) and Graphs. I can explain the "Flood Fill" algorithm which is very intuitive.